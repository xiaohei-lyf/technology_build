方案2：如图2所示。c1、c2、c3三个进程都去请求加锁，c1首先获得了锁并设置了有效时间，此刻c2、c3无法获得该锁。那么c2、c3等待一段时间后再次访问。过来一段时间后c2、c3再次请求锁时发现c1的锁已经过了有效时间，c2先进行操作，此时不是删除c1的锁，而是再次取得该锁的有效时间进行核对发现该锁确实是已经失效，然后赋予该锁一个新的值获得锁。随后c3取得c2刚刚更新的锁的失效时间发现未实效，继续等待。可以看到这种方式对失效时间其实是进行了两次校验，既解决了死锁问题，又避免方案1中误删锁的现象发生。在这个方案中一般我们使用getset方法进行操作。
————————————————
版权声明：本文为CSDN博主「HMenen」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_17288553/article/details/84316709